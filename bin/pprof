#!/usr/bin/env ruby

require 'pprof'
require 'optparse'


def matcher(string)
  m = string.match(%r[^/(.*)/(.*)$])
  if m.nil?
    Regexp.new(Regexp.escape(string))
  else
    Regexp.new(m[1], m[2].empty? ? nil : m[2])
  end
end

# Command Line Parsing

filters = {}
options = {}
parser = OptionParser.new do |opts|
  opts.banner = <<-BANNER.gsub(/^ *\|/,'')
    |Usage:
    |  pprof [options] [PATH|UUID]
    |  pprof [filters]
    |
    |Note: All filters expecting a string are interpreted as regular expressions if surrounded by slashes
  BANNER

  opts.separator ""
  opts.separator "Print options"

  opts.on("-i", "--info", "Print general info (default)") do
    options[:info] = true
  end
  opts.on("-c", "--certs", "Print certificates") do
    options[:certs] = true
  end
  opts.on("-d", "--devices", "Print provisioned devices") do
    options[:devices] = true
  end

  opts.separator ""
  opts.separator "Filters"

  opts.on("-n", "--name NAME", "Filter by name") do |name|
    filters[:name] = matcher(name)
  end

  opts.on("--appid-name APPID", "Filter by App ID Name") do |appid_name|
    filters[:appid_name] = matcher(appid_name)
  end

  opts.on("-a", "--appid APPID", "Filter by App ID") do |appid|
    filters[:appid] = matcher(appid)
  end

  opts.on("--uuid UUID", "Filter by UUID") do |uuid|
    filters[:uuid] = matcher(uuid)
  end

  opts.on("-e", "--no-exp [DATE]", "Only profiles (not) expired") do |flag|
    filters[:exp] = flag
  end

  opts.on("--[no-]has-devices", "Filter by profiles having (no) provisioned devices") do |d|
    filters[:has_devices] = d
  end

  opts.on("--[no-]all-devices", "Filter by profiles (not) provisioning all devices") do |d|
    filters[:all_devices] = d
  end

  opts.on("--aps [ENV]", "Only profiles having Push entitlements (on a specific aps env)") do |env|
    filters[:aps_env] = env.nil? ? true : matcher(env)
  end


  opts.separator ""
  opts.separator "Misc"

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  opts.on_tail("-v", "--version", "Show version") do
    puts PProf::VERSION
    exit
  end
end

# Parse the options, catching parse errors nicely
begin
  parser.parse!
rescue OptionParser::InvalidOption => err
  puts err
  puts parser.help()
  exit 1
end

# Don't mix filters and options together, that doesn't make sense

unless filters.empty? || ARGV.empty?
  puts "You should use either filter flags to filter the whole list, or an specific path, not both."
  puts parser # Usage
  exit
end

unless options.empty? || !ARGV.empty?
  puts "You should use option flags only when providing an specific path."
  puts parser # Usage
  exit
end

# Call the appropriate action

if ARGV.empty?
  # Print list of matching profiles
  o = PProf::OutputFormatter.new
  o.print_filtered_list(PProf::ProvisioningProfile::DEFAULT_DIR, filters)
else
  # Print info about given profile path/UUID
  p = PProf::ProvisioningProfile.new(ARGV[0])
  
  o = PProf::OutputFormatter.new
  options = { :info => true } if options.empty?
  o.print_info(p, options)
end
